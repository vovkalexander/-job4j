1) Используем количество создаваемых объектов до 10 миллионов, чтобы задействовать все
области памяти в различных видов сборщиков мусора.
Для получения информации о сборщике мусора используем ключ -XX:+PrintGCDetails.
а) используем Serial GC (он же последовательный сборщик)  ключ -XX:+UseSerialGC.
время потраченное на выполнения сборку мусора - 5 сек.
пауза остановки приложения в среднем  составило 403 мсек.
максимальное остановка приложения составило 836мсек

б) используем Parallel GC, ключ -XX:+UseParallelGC
время потраченное на выполнения сборку мусора - 8 сек.
пауза остановки приложения в среднем составило - 209 мсек.
максимальное остановка приложения составило 1 сек 968мсек

в) используем Parallel Compacting GC ключ -XX:+UseParallelOldGC
время потраченное на выполнения сборку мусора - 6 сек
пауза остановки приложения в среднем составило - 194 мсек
максимальное остановка приложения составило 1 сек 571мсек

г) используем Concurrent Mark-Sweep GC ключ –XX:+UseConcMarkSweepGC
время потраченное на выполнения сборку мусора - 4 сек
пауза остановки приложения в среднем составило - 393 мсек
максимальное остановка приложения составило - 1 сек 952 мсек

д) используем G1 GC выполняется по умолчанию, либо ключ -XX:+UseG1GC
время потраченное на выполнения сборку мусора - 3 сек
пауза остановки приложения в среднем составило - 253 мсек
максимальное остановка приложения составило - 449 мсек

2) Из полученных экспериментальных  данных  срабатывания  сборщиков мусора для программы из первого урока,
использовал G1, Concurrent Mark-Sweep GC, и  Serial GC.

3)Для приложения заявок из второго модуля подойдет любой вид сборщика мусора, т.к.
программа работает в режиме клиет-приложения на одной машине и нет требования к паузам - остановки
приложения, во время работы сборщика.

4) Для серверного приложения лучше всего использовать Concurrent Mark-Sweep GC и G1
так как основное требования серверных приложений  к сборщику - снижения  простоя приложения, во
время работы сборщика.